import { createCollection,  } from "@ripple-primitives/collection";
import { trackProps, Primitive, composeEventHandlers } from "@ripple-primitives/primitive-ui";
import { UseControllableState, ControllableState } from "@ripple-primitives/use-controllable-state";
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from "@ripple-primitives/collapsible";
import { useDirection } from "@ripple-primitives/direction";
import { Context, track, effect, untrack } from "ripple";

type Direction = 'ltr' | 'rtl';
/* -------------------------------------------------------------------------------------------------
 * Accordion
 * -----------------------------------------------------------------------------------------------*/
const [CollectionContext, CollectionProvider] = createCollection();
const ACCORDION_NAME = 'Accordion';
const ACCORDION_KEYS = ['Home', 'End', 'ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'];

const AccordionContext = new Context({});

export component Accordion(props){
  const { type, ...accordionProps } = trackProps(props);
  const singleProps = accordionProps;
  const multipleProps = accordionProps;

  const items = #[];
  const getItems = () => items;
  const addItem = (item) => {
    items.push(item);
  };
  const removeItem = (triggerId) => {
    const itemIndex = items.findIndex(i => i.triggerId == triggerId);
    items.splice(itemIndex, 1)
  }

  AccordionContext.set({ getItems, addItem, removeItem })

  if(@type === 'multiple') {
    <AccordionImplMultiple {...multipleProps}/>
  }
  else {
    <AccordionImplSingle {...singleProps} />
  }
}

component AccordionImplMultiple(props) {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {},
    collapsible = true,
    ...accordionMultipleProps
  } = props;

  const value = UseControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: ACCORDION_NAME
  });

  const onItemOpen = (itemValue: string) => {
    @value = [...@value, itemValue];
  }
  const onItemClose = (itemValue: string) => {
    @value = @value.filter(value => value !== itemValue)
  }
  const context = AccordionContext.get();
  AccordionContext.set({...context, collapsible, value, onItemOpen, onItemClose});

  <AccordionImpl {...accordionMultipleProps} />
}

component AccordionImplSingle(props){
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {},
    collapsible = false,
    ...accordionSingleProps
  } = props;

  const value = UseControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? '',
    onChange: onValueChange,
    caller: ACCORDION_NAME
  });

  const valueContext = track(() => #[@value]);
  const onItemOpen = (itemValue: string) => {
    @value = itemValue;
  }
  const onItemClose = (itemValue: string) => {
    if(@collapsible) {
      @value = '';
    }
  }
  const context = AccordionContext.get();
  AccordionContext.set({ ...context, collapsible, value: valueContext, onItemOpen, onItemClose});

  <AccordionImpl {...accordionSingleProps} />
}

component AccordionImpl(props){
  const { disabled, dir, orientation = 'vertical', ...accordionProps} = props;
  const direction = track(() => useDirection(@dir))
  const context = AccordionContext.get();
  AccordionContext.set({...context, direction, disabled, orientation});

  const handleKeyDown = composeEventHandlers(props.onKeyDown, (event) => {
    
    if (!ACCORDION_KEYS.includes(event.key)) return;
    const target = event.target as HTMLElement;
    const triggerCollection = context.getItems().filter((item) => !item.node?.disabled);
    const triggerIndex = triggerCollection.findIndex((item) => item.node === target);
    const triggerCount = triggerCollection.length;
    const isDirectionLTR = @direction === 'ltr';
    if (triggerIndex === -1) return;

    // Prevents page scroll while user is navigating
    event.preventDefault();

    let nextIndex = triggerIndex;
    const homeIndex = 0;
    const endIndex = triggerCount - 1;

    const moveNext = () => {
      nextIndex = triggerIndex + 1;
      if (nextIndex > endIndex) {
        nextIndex = homeIndex;
      }
    };

    const movePrev = () => {
      nextIndex = triggerIndex - 1;
      if (nextIndex < homeIndex) {
        nextIndex = endIndex;
      }
    };

    switch (event.key) {
        case 'Home':
          nextIndex = homeIndex;
          break;
        case 'End':
          nextIndex = endIndex;
          break;
        case 'ArrowRight':
          if (@orientation === 'horizontal') {
            if (isDirectionLTR) {
              moveNext();
            } else {
              movePrev();
            }
          }
          break;
        case 'ArrowDown':
          if (@orientation === 'vertical') {
            moveNext();
          }
          break;
        case 'ArrowLeft':
          if (@orientation === 'horizontal') {
            if (isDirectionLTR) {
              movePrev();
            } else {
              moveNext();
            }
          }
          break;
        case 'ArrowUp':
          if (@orientation === 'vertical') {
            movePrev();
          }
          break;
      }
    const clampedIndex = nextIndex % triggerCount;
    triggerCollection[clampedIndex].node?.focus();
  });
  
  <Primitive.div
    {...accordionProps}
    data-orientation={@orientation}
    onKeyDown={@disabled ? undefined : handleKeyDown}
  />
}


/* -------------------------------------------------------------------------------------------------
 * AccordionItem
 * -----------------------------------------------------------------------------------------------*/
const ItemContext = new Context({});

const ITEM_NAME = 'AccordionItem';
export component AccordionItem(props){
  const { value, disabled, ...accordionItemProps } = trackProps(props);
  const accordionContext = AccordionContext.get();
  const triggerId = track(() => Date.now());
  
  const open = track(() => {
    return (@value && accordionContext.@value.includes(@value)) || false;
  });

  ItemContext.set({ open, disabled, triggerId});
  
  <Collapsible
    data-orientation={accordionContext.@orientation}
    data-state={getState(@open)}
    {...accordionItemProps}
    disabled={accordionContext.@disabled || @disabled}
    open={@open}
    onOpenChange={(open) => {
      console.log("onOpenChange", open, @value)
      if (open) {
        accordionContext.onItemOpen(@value);
      } else {
        accordionContext.onItemClose(@value);
      }
    }}
  />
}

/* -------------------------------------------------------------------------------------------------
 * AccordionHeader
 * -----------------------------------------------------------------------------------------------*/

const HEADER_NAME = 'AccordionHeader';
export component AccordionHeader(props){
  const {...headerProps} = trackProps(props);
  const accordionContext = AccordionContext.get();
  const itemContext = ItemContext.get();

  <Primitive.h3 
    data-orientation={accordionContext.@orientation}
    data-state={getState(itemContext.@open)}
    data-disabled={itemContext.@disabled ? '' : undefined}
    {...headerProps} 
  />
}
AccordionHeader.displayName = HEADER_NAME;

/* -------------------------------------------------------------------------------------------------
 * AccordionTrigger
 * -----------------------------------------------------------------------------------------------*/

const TRIGGER_NAME = 'AccordionTrigger';
export component AccordionTrigger(props){
  const { ...triggerProps } = trackProps(props);
  const itemContext = ItemContext.get();
  const accordionContext = AccordionContext.get();
  
  const triggerRef = (n) => {
    const triggerId = untrack(() => itemContext.@triggerId);
    const addItem = untrack(() => accordionContext.addItem);
    const removeItem = untrack(() => accordionContext.removeItem);
    untrack(() => {
      setTimeout(() => addItem({ triggerId, node: n}))
    })
    return () => {
      console.log("unmount")
      untrack(() => () => {
        setTimeout(() => removeItem(triggerId))
        console.log("unmount", triggerId);
      })
    }
  }

  <CollapsibleTrigger 
    {ref triggerRef}
    aria-disabled={(itemContext.@open && !accordionContext.@collapsible) || undefined}
    data-orientation={accordionContext.@orientation}
    id={itemContext.@triggerId}
    {...triggerProps}
  />
}
AccordionTrigger.displayName = TRIGGER_NAME;


/* -------------------------------------------------------------------------------------------------
 * AccordionContent
 * -----------------------------------------------------------------------------------------------*/

const CONTENT_NAME = 'AccordionContent';
export component AccordionContent(props){
  const { ...contentProps } = trackProps(props);
  const itemContext = ItemContext.get();
  const accordionContext = AccordionContext.get();
  <CollapsibleContent 
    role="region"
    aria-labelledby={itemContext.@triggerId}
    data-orientation={accordionContext.@orientation}
    {...contentProps}
    style={{
      ['--radix-accordion-content-height' as any]: 'var(--radix-collapsible-content-height)',
      ['--radix-accordion-content-width' as any]: 'var(--radix-collapsible-content-width)',
      ...props.style,
    }}
  />
}
AccordionContent.displayName = CONTENT_NAME;

/* -----------------------------------------------------------------------------------------------*/

function getState(open?: boolean) {
  return open ? 'open' : 'closed';
}