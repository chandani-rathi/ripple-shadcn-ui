import { Context, track, effect, untrack, bindNode, tick } from "ripple";
import { Primitive, trackProps } from "@ripple-primitives/primitive-ui";
import { UseControllableState } from "@ripple-primitives/use-controllable-state";
import { composeEventHandlers } from "@ripple-primitives/primitive";
import { Presence } from "@ripple-primitives/presence"
const NAME = 'Collapsible';

const CollapsibleContext = new Context({});

export component Collapsible(props){
  const { 
    open: openProp,
    defaultOpen,
    disabled,
    onOpenChange,
    children: Children,
    ...collapsibleProps
  } = trackProps(props);

  const open = UseControllableState({
    prop: openProp, 
    defaultProp: defaultOpen ?? false, 
    onChange: onOpenChange, 
    caller: NAME
  });

  const contentId = track(() => Date.now());
  const onOpenToggle = () => {
    @open = !@open;
  }
  CollapsibleContext.set({ open, onOpenToggle, disabled, contentId});

  <Primitive.div 
    data-state={getState(@open)}
    data-disabled={@disabled ? '' : undefined}
    {...collapsibleProps}
  >
    component children(childProps){
      <@Children {...childProps} />
    }
  </Primitive.div>
}


/* -------------------------------------------------------------------------------------------------
 * CollapsibleTrigger
 * -----------------------------------------------------------------------------------------------*/

const TRIGGER_NAME = 'CollapsibleTrigger';
export component CollapsibleTrigger(props){
  const {...triggerProps} = trackProps(props);
  const context = CollapsibleContext.get();

  <Primitive.button
    type="button"
    aria-controls={context.@contentId}
    aria-expanded={context.@open || false}
    data-state={getState(context.@open)}
    data-disabled={context.@disabled ? '' : undefined}
    disabled={context.@disabled}
    {...triggerProps}
    onClick={composeEventHandlers(triggerProps.onClick, context.onOpenToggle)}
      />
}
CollapsibleTrigger.displayName = TRIGGER_NAME

/* -------------------------------------------------------------------------------------------------
 * CollapsibleContent
 * -----------------------------------------------------------------------------------------------*/

const CONTENT_NAME = 'CollapsibleContent';
export component CollapsibleContent(props){
  const { forceMount, ...contentProps } = trackProps(props);
  const context = CollapsibleContext.get();
  <Presence present={@forceMount || context.@open}>
    component children({ present, ...presentProps }){
      <CollapsibleContentImpl {...contentProps} {...presentProps} {present} />
    }
  </Presence>
}

component CollapsibleContentImpl(props){
  const { present, children: Children, style, ...contentProps } = props;
  const context = CollapsibleContext.get();
  const isPresent = track(@present);
  // when opening we want it to immediately open to retrieve dimensions
  // when closing we delay `present` to retrieve dimensions before closing
  const isOpen = track(() => context.@open || @isPresent);
  const height = track(0);
  const width = track(0);
  let node = track<HTMLElement>(null);

  effect(() => {
    //const hasOpen = context.@open;
    const hasPresent = @present;
    const nodeRef = untrack(() => @node)
    
      //tick().then(() => {
        if(nodeRef) {
          const styleRef = untrack(() => @node.style)
          const { rect, originalTransitionDuration, originalAnimationName } = untrack(() => {
            const originalTransitionDuration = styleRef.transitionDuration;
            const originalAnimationName = styleRef.animationName;
            styleRef.transitionDuration = '0s';
            styleRef.animationName = 'none';
            const rect = nodeRef.getBoundingClientRect()
            return { rect, originalAnimationName, originalTransitionDuration};
          });
          @height = rect.height;
          @width = rect.width;
          //console.log("calculated..", untrack(() => ({ @height, @width})));
          nodeRef.style.transitionDuration = originalTransitionDuration;
          nodeRef.style.animationName = originalAnimationName;
          
          @isPresent = hasPresent;
        }
      //});
  });

  <Primitive.div 
    {ref bindNode(node)}
    data-state={getState(context.@open)}
    data-disabled={context.@disabled ? '' : undefined}
    id={context.@contentId}
    hidden={!@isOpen}
    {...contentProps}
    style={{
      [`--radix-collapsible-content-height` as any]: @height ? `${@height}px` : undefined,
      [`--radix-collapsible-content-width` as any]: @width ? `${@width}px` : undefined,
      ...@style,
    }}
  >
    component children(childProps){
      if(@isOpen) {
        <@Children {...childProps} />
      }
    }
  </Primitive.div>
}

/* -----------------------------------------------------------------------------------------------*/

function getState(open?: boolean) {
  return open ? 'open' : 'closed';
}