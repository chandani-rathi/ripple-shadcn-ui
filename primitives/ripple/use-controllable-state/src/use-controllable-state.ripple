import { track, effect } from 'ripple'
const NAME = 'UseControllableState';

function useUncontrolledState({
  defaultProp, onChange
})
{
  const value = track(() => @defaultProp, undefined,
    (next, prev) => {
      @onChange(next);
      return next;
    });
  return value;
}

export function UseControllableState({ prop, defaultProp, onChange = () => {}, caller  }){

  const isControlled = @prop !== undefined;
  const doChange = next => setTimeout(() => {
    @onChange(next);
    if(prop && !prop.isTrackedProxy) {
      @prop = next;
    }
  });
  
  if(!isControlled){
    const uncontrolledProp = useUncontrolledState({
      defaultProp,
      onChange: doChange,
    });
    return uncontrolledProp;
  }

  effect(() => {
    const hasControlled = @prop !== undefined;
    if(isControlled != hasControlled) {
      const from = isControlled ? 'controlled' : 'uncontrolled';
      const to = hasControlled ? 'controlled' : 'uncontrolled';
      console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      );
    }
  });

  return track(() => @prop, undefined, (next, prev) => {
      doChange(next);
      return prev;
  });
}

export component ControllableState({ prop, defaultProp, onChange = () => {}, caller, children, ...props }){

  const isControlled = prop !== undefined;
  effect(() => {
    const hasControlled = prop !== undefined;
    if(isControlled != hasControlled) {
      const from = isControlled ? 'controlled' : 'uncontrolled';
      const to = hasControlled ? 'controlled' : 'uncontrolled';
      console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      );
    }
  });
 
  const doChange = v => setTimeout(() => @onChange(v));
  if(isControlled) {
    const state = track(() => prop, undefined, (next, prev) => {
      doChange(next);
      return prev;
    });
    <@children {state} {...props} />
  }
  else {
    const state = track(() => @defaultProp, undefined, (next, prev) => {
      doChange(next);
      return next;
    });
    <@children {state} {...props} />
  }
}